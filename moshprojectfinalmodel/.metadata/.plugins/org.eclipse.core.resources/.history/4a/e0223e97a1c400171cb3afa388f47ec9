package moshproject.agents.passenger;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import moshproject.agents.mode.Cycle;
import moshproject.agents.mode.Mode;
import moshproject.agents.mode.PersonalVehicle;
import moshproject.agents.mode.PublicTransport;
import moshproject.agents.mode.Walking;
import moshproject.fuzzycollections.DecisionGenerator;
import repast.simphony.random.RandomHelper;
import repast.simphony.space.continuous.ContinuousSpace;
import repast.simphony.space.grid.Grid;

public abstract class Passengers {
	Random  rand = new Random();
	double socialFlexibility;
	double subsistenceSatisfaction;
	double subsistencerigour;
	double socialRigour;
	boolean socialAgreeability;
	double socialFrequency;
	double uncertainty;
	double socialUncertainty;
	double personaluncertainty;
	double changeInExperience;
	double levelOfneedsSatisfaction;
	double previousExperience;
	double socialSatisfaction;
	double assumedMaximumDifference;
	double uncertaintyTolerance;
	double aspirationLevel;	
	Mode prefferedMode;
	
	//Behaviour behaviour; 
	
	
	double personalSatisfaction;
	double physicalConsideration;
	double cognitiveConsideration;
	double affectiveConsideration;
	
	private ContinuousSpace<Object> space;
	private Grid<Object> grid;
	
	


	List<Mode> prefferedModeList = new ArrayList<Mode>();
	
	public Passengers(ContinuousSpace<Object> space, Grid<Object> grid) {
		this.space = space;
		this.grid = grid;
		socialAgreeability =false; 
		socialSatisfaction =0.0;
		assumedMaximumDifference =0.5;
		previousExperience=0.0;
		levelOfneedsSatisfaction=0.0;	
		uncertaintyTolerance = RandomHelper.nextDoubleFromTo(0.1, 0.9);
		aspirationLevel = RandomHelper.nextDoubleFromTo(0.2, 1.0);
		uncertainty = allUncertainty();
	}
	
	
	// Social uncertainty is the failed expectation during imitation and inquiring
	private double socialUncertainty(){
		socialUncertainty = rand.nextDouble();
		return socialUncertainty;
	}
///Total source of uncertainties which can come form personal opinion and social failures		
	private double allUncertainty(){
		double	totalUncertainty= (personalUncertainty() + socialUncertainty())/2;
		if(totalUncertainty<0.0){
			uncertainty= (1-(Math.abs(totalUncertainty)));
		}else{
			uncertainty= totalUncertainty;
		}
	return uncertainty;
	}

	//Personal uncertainty 
	private double personalUncertainty(){
		personaluncertainty =0.0;
		double passuncertainty = this.changeInExperience();
			if(passuncertainty<0.0){
				personaluncertainty= (1-(Math.abs(passuncertainty)));
			}else{
				personaluncertainty= passuncertainty;
			}
		
			return personaluncertainty;
		}
	
	
	@SuppressWarnings("unused")
	private void setLevelOfneedsSatisfaction(double levelOfneedsSatisfaction) {
		this.levelOfneedsSatisfaction = levelOfneedsSatisfaction;
	}
	
	private double changeInExperience(){
		//levelOfneedsSatisfaction= setLevelOfneedsSatisfaction();
		changeInExperience = levelOfneedsSatisfaction-previousExperience;
		if(changeInExperience<0){
			changeInExperience=0.0;
		}
		return changeInExperience;
	}
		 
	// This section evaluate passengers satisfaction on the major factors
//			double getPersonalSatisfaction() {					
//				TravelDemandFactors.updatePhysicalConsideration();
//				TravelDemandFactors.updateCognitiveConsideration();
//				TravelDemandFactors.updateAffectiveConsideration();				
//				personalSatisfaction = evaluateSatisfaction.getTip(physicalConsideration, cognitiveConsideration,affectiveConsideration);
//			
//					return personalSatisfaction;
//				}
				
			
		 public void updatePreviousExperience(List <Double> modeSatisfactionList){
						if(modeSatisfactionList.size()==0){
							previousExperience=0.0;
						}else{													
							previousExperience=	modeSatisfactionList.get(modeSatisfactionList.size()-1);						
						}
					}
			
}
